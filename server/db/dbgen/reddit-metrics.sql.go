// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: reddit-metrics.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getRedditCommentMetricsByIDs = `-- name: GetRedditCommentMetricsByIDs :many
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.score::REAL AS "value",
    'reddit.comment.score' AS "metric"
FROM reddit_comment_score AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.controversiality::REAL AS "value",
    'reddit.comment.controversiality' AS "metric"
FROM reddit_comment_controversiality AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
`

type GetRedditCommentMetricsByIDsParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditCommentMetricsByIDsRow struct {
	ID     string             `json:"id"`
	Ts     pgtype.Timestamptz `json:"ts"`
	Value  float32            `json:"value"`
	Metric string             `json:"metric"`
}

func (q *Queries) GetRedditCommentMetricsByIDs(ctx context.Context, arg GetRedditCommentMetricsByIDsParams) ([]GetRedditCommentMetricsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getRedditCommentMetricsByIDs, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditCommentMetricsByIDsRow
	for rows.Next() {
		var i GetRedditCommentMetricsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditCommentMetricsByIDsBucket15Min = `-- name: GetRedditCommentMetricsByIDsBucket15Min :many


SELECT id, bucket, value, 'reddit.comment.score' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(score::REAL) AS "value"
	FROM reddit_comment_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.comment.controversiality' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(controversiality::REAL) AS "value"
	FROM reddit_comment_controversiality
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditCommentMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditCommentMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

// Reddit Comment Bucketed Metrics
func (q *Queries) GetRedditCommentMetricsByIDsBucket15Min(ctx context.Context, arg GetRedditCommentMetricsByIDsBucket15MinParams) ([]GetRedditCommentMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getRedditCommentMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditCommentMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetRedditCommentMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditCommentMetricsByIDsBucket1Day = `-- name: GetRedditCommentMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'reddit.comment.score' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(score::REAL) AS value
	FROM reddit_comment_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.comment.controversiality' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(controversiality::REAL) AS value
	FROM reddit_comment_controversiality
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditCommentMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditCommentMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditCommentMetricsByIDsBucket1Day(ctx context.Context, arg GetRedditCommentMetricsByIDsBucket1DayParams) ([]GetRedditCommentMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getRedditCommentMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditCommentMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetRedditCommentMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditCommentMetricsByIDsBucket1Hr = `-- name: GetRedditCommentMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'reddit.comment.score' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(score::REAL) AS value
	FROM reddit_comment_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.comment.controversiality' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(controversiality::REAL) AS value
	FROM reddit_comment_controversiality
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditCommentMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditCommentMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditCommentMetricsByIDsBucket1Hr(ctx context.Context, arg GetRedditCommentMetricsByIDsBucket1HrParams) ([]GetRedditCommentMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditCommentMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditCommentMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetRedditCommentMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditCommentMetricsByIDsBucket8Hr = `-- name: GetRedditCommentMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'reddit.comment.score' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS bucket,
	    MAX(score::REAL) AS value
	FROM reddit_comment_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.comment.controversiality' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(controversiality::REAL) AS "value"
	FROM reddit_comment_controversiality
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditCommentMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditCommentMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditCommentMetricsByIDsBucket8Hr(ctx context.Context, arg GetRedditCommentMetricsByIDsBucket8HrParams) ([]GetRedditCommentMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditCommentMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditCommentMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetRedditCommentMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditPostMetricsByIDs = `-- name: GetRedditPostMetricsByIDs :many
SELECT
    id AS "id",
    ts AS "ts",
    score::REAL AS "value",
    'reddit.post.score' AS "metric"
FROM reddit_post_score AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    id AS "id",
    ts AS "ts",
    ratio::REAL AS "value",
    'reddit.post.ratio' AS "metric"
FROM reddit_post_ratio AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
`

type GetRedditPostMetricsByIDsParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditPostMetricsByIDsRow struct {
	ID     string             `json:"id"`
	Ts     pgtype.Timestamptz `json:"ts"`
	Value  float32            `json:"value"`
	Metric string             `json:"metric"`
}

func (q *Queries) GetRedditPostMetricsByIDs(ctx context.Context, arg GetRedditPostMetricsByIDsParams) ([]GetRedditPostMetricsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getRedditPostMetricsByIDs, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditPostMetricsByIDsRow
	for rows.Next() {
		var i GetRedditPostMetricsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditPostMetricsByIDsBucket15Min = `-- name: GetRedditPostMetricsByIDsBucket15Min :many

SELECT id, bucket, value, 'reddit.post.score' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(score::REAL) AS "value"
	FROM reddit_post_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.post.ratio' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(ratio::REAL) AS "value"
	FROM reddit_post_ratio
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditPostMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditPostMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

// Reddit Post Bucketed Metrics
func (q *Queries) GetRedditPostMetricsByIDsBucket15Min(ctx context.Context, arg GetRedditPostMetricsByIDsBucket15MinParams) ([]GetRedditPostMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getRedditPostMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditPostMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetRedditPostMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditPostMetricsByIDsBucket1Day = `-- name: GetRedditPostMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'reddit.post.score' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(score::REAL) AS value
	FROM reddit_post_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.post.ratio' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(ratio::REAL) AS value
	FROM reddit_post_ratio
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditPostMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditPostMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditPostMetricsByIDsBucket1Day(ctx context.Context, arg GetRedditPostMetricsByIDsBucket1DayParams) ([]GetRedditPostMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getRedditPostMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditPostMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetRedditPostMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditPostMetricsByIDsBucket1Hr = `-- name: GetRedditPostMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'reddit.post.score' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(score::REAL) AS value
	FROM reddit_post_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.post.ratio' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(ratio::REAL) AS value
	FROM reddit_post_ratio
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditPostMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditPostMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditPostMetricsByIDsBucket1Hr(ctx context.Context, arg GetRedditPostMetricsByIDsBucket1HrParams) ([]GetRedditPostMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditPostMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditPostMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetRedditPostMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditPostMetricsByIDsBucket8Hr = `-- name: GetRedditPostMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'reddit.post.score' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS bucket,
	    MAX(score::REAL) AS value
	FROM reddit_post_score
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.post.ratio' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(ratio::REAL) AS "value"
	FROM reddit_post_ratio
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditPostMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditPostMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditPostMetricsByIDsBucket8Hr(ctx context.Context, arg GetRedditPostMetricsByIDsBucket8HrParams) ([]GetRedditPostMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditPostMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditPostMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetRedditPostMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditSubredditMetricsByIDs = `-- name: GetRedditSubredditMetricsByIDs :many
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.subscribers::REAL AS "value",
    'reddit.subreddit.subscribers' AS "metric"
FROM reddit_subreddit_subscribers AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.active_user_count::REAL AS "value",
    'reddit.subreddit.active-user-count' AS "metric"
FROM reddit_subreddit_active_user_count AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
`

type GetRedditSubredditMetricsByIDsParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditSubredditMetricsByIDsRow struct {
	ID     string             `json:"id"`
	Ts     pgtype.Timestamptz `json:"ts"`
	Value  float32            `json:"value"`
	Metric string             `json:"metric"`
}

func (q *Queries) GetRedditSubredditMetricsByIDs(ctx context.Context, arg GetRedditSubredditMetricsByIDsParams) ([]GetRedditSubredditMetricsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getRedditSubredditMetricsByIDs, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditSubredditMetricsByIDsRow
	for rows.Next() {
		var i GetRedditSubredditMetricsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditSubredditMetricsByIDsBucket15Min = `-- name: GetRedditSubredditMetricsByIDsBucket15Min :many


SELECT id, bucket, value, 'reddit.subreddit.subscribers' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(subscribers::REAL) AS "value"
	FROM reddit_subreddit_subscribers
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.subreddit.active-user-count' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(active_user_count::REAL) AS "value"
	FROM reddit_subreddit_active_user_count
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditSubredditMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditSubredditMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

// Reddit Subreddit Bucketed Metrics
func (q *Queries) GetRedditSubredditMetricsByIDsBucket15Min(ctx context.Context, arg GetRedditSubredditMetricsByIDsBucket15MinParams) ([]GetRedditSubredditMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getRedditSubredditMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditSubredditMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetRedditSubredditMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditSubredditMetricsByIDsBucket1Day = `-- name: GetRedditSubredditMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'reddit.subreddit.subscribers' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(subscribers::REAL) AS value
	FROM reddit_subreddit_subscribers
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.subreddit.active-user-count' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(active_user_count::REAL) AS value
	FROM reddit_subreddit_active_user_count
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditSubredditMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditSubredditMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditSubredditMetricsByIDsBucket1Day(ctx context.Context, arg GetRedditSubredditMetricsByIDsBucket1DayParams) ([]GetRedditSubredditMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getRedditSubredditMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditSubredditMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetRedditSubredditMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditSubredditMetricsByIDsBucket1Hr = `-- name: GetRedditSubredditMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'reddit.subreddit.subscribers' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(subscribers::REAL) AS value
	FROM reddit_subreddit_subscribers
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.subreddit.active-user-count' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(active_user_count::REAL) AS value
	FROM reddit_subreddit_active_user_count
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditSubredditMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditSubredditMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditSubredditMetricsByIDsBucket1Hr(ctx context.Context, arg GetRedditSubredditMetricsByIDsBucket1HrParams) ([]GetRedditSubredditMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditSubredditMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditSubredditMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetRedditSubredditMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditSubredditMetricsByIDsBucket8Hr = `-- name: GetRedditSubredditMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'reddit.subreddit.subscribers' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS bucket,
	    MAX(subscribers::REAL) AS value
	FROM reddit_subreddit_subscribers
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.subreddit.active-user-count' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(active_user_count::REAL) AS "value"
	FROM reddit_subreddit_active_user_count
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditSubredditMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditSubredditMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditSubredditMetricsByIDsBucket8Hr(ctx context.Context, arg GetRedditSubredditMetricsByIDsBucket8HrParams) ([]GetRedditSubredditMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditSubredditMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditSubredditMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetRedditSubredditMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditUserMetricsByIDs = `-- name: GetRedditUserMetricsByIDs :many
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.karma::REAL AS "value",
    'reddit.user.awardee-karma' AS "metric"
FROM reddit_user_awardee_karma AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.karma::REAL AS "value",
    'reddit.user.awarder-karma' AS "metric"
FROM reddit_user_awarder_karma AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.karma::REAL AS "value",
    'reddit.user.comment-karma' AS "metric"
FROM reddit_user_comment_karma AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.karma::REAL AS "value",
    'reddit.user.link-karma' AS "metric"
FROM reddit_user_link_karma AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
UNION ALL
SELECT
    r.id AS "id",
    r.ts AS "ts",
    r.karma::REAL AS "value",
    'reddit.user.total-karma' AS "metric"
FROM reddit_user_total_karma AS r
WHERE
    r.id = ANY($1::VARCHAR[]) AND
    r.ts >= $2 AND
    r.ts <= $3
`

type GetRedditUserMetricsByIDsParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditUserMetricsByIDsRow struct {
	ID     string             `json:"id"`
	Ts     pgtype.Timestamptz `json:"ts"`
	Value  float32            `json:"value"`
	Metric string             `json:"metric"`
}

func (q *Queries) GetRedditUserMetricsByIDs(ctx context.Context, arg GetRedditUserMetricsByIDsParams) ([]GetRedditUserMetricsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getRedditUserMetricsByIDs, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditUserMetricsByIDsRow
	for rows.Next() {
		var i GetRedditUserMetricsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditUserMetricsByIDsBucket15Min = `-- name: GetRedditUserMetricsByIDsBucket15Min :many


SELECT id, bucket, value, 'reddit.user.awardee-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_awardee_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.awarder-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_awarder_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.comment-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_comment_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.link-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_link_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.total-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_total_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditUserMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditUserMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

// Reddit User Bucketed Metrics
func (q *Queries) GetRedditUserMetricsByIDsBucket15Min(ctx context.Context, arg GetRedditUserMetricsByIDsBucket15MinParams) ([]GetRedditUserMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getRedditUserMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditUserMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetRedditUserMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditUserMetricsByIDsBucket1Day = `-- name: GetRedditUserMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'reddit.user.awardee-karma' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(karma::REAL) AS value
	FROM reddit_user_awardee_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.awarder-karma' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS bucket,
	    MAX(karma::REAL) AS value
	FROM reddit_user_awarder_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
	UNION ALL
SELECT id, bucket, value, 'reddit.user.comment-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_comment_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.link-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_link_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.total-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_total_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditUserMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditUserMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditUserMetricsByIDsBucket1Day(ctx context.Context, arg GetRedditUserMetricsByIDsBucket1DayParams) ([]GetRedditUserMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getRedditUserMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditUserMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetRedditUserMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditUserMetricsByIDsBucket1Hr = `-- name: GetRedditUserMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'reddit.user.awardee-karma' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(karma::REAL) AS value
	FROM reddit_user_awardee_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.awarder-karma' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS bucket,
	    MAX(karma::REAL) AS value
	FROM reddit_user_awarder_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.comment-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_comment_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.link-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_link_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.total-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_total_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditUserMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditUserMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditUserMetricsByIDsBucket1Hr(ctx context.Context, arg GetRedditUserMetricsByIDsBucket1HrParams) ([]GetRedditUserMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditUserMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditUserMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetRedditUserMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedditUserMetricsByIDsBucket8Hr = `-- name: GetRedditUserMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'reddit.user.awardee-karma' AS metric
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS bucket,
	    MAX(karma::REAL) AS value
	FROM reddit_user_awardee_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.awarder-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_awarder_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.comment-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_comment_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.link-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_link_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'reddit.user.total-karma' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(karma::REAL) AS "value"
	FROM reddit_user_total_karma
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id = ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetRedditUserMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetRedditUserMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetRedditUserMetricsByIDsBucket8Hr(ctx context.Context, arg GetRedditUserMetricsByIDsBucket8HrParams) ([]GetRedditUserMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getRedditUserMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRedditUserMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetRedditUserMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRedditCommentControversiality = `-- name: InsertRedditCommentControversiality :exec
INSERT INTO reddit_comment_controversiality (id, ts, controversiality)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditCommentControversialityParams struct {
	ID               string  `json:"id"`
	Controversiality float32 `json:"controversiality"`
}

func (q *Queries) InsertRedditCommentControversiality(ctx context.Context, arg InsertRedditCommentControversialityParams) error {
	_, err := q.db.Exec(ctx, insertRedditCommentControversiality, arg.ID, arg.Controversiality)
	return err
}

const insertRedditCommentScore = `-- name: InsertRedditCommentScore :exec
INSERT INTO reddit_comment_score (id, ts, score)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditCommentScoreParams struct {
	ID    string `json:"id"`
	Score int32  `json:"score"`
}

func (q *Queries) InsertRedditCommentScore(ctx context.Context, arg InsertRedditCommentScoreParams) error {
	_, err := q.db.Exec(ctx, insertRedditCommentScore, arg.ID, arg.Score)
	return err
}

const insertRedditPostRatio = `-- name: InsertRedditPostRatio :exec
INSERT INTO reddit_post_ratio (id, ts, ratio)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditPostRatioParams struct {
	ID    string  `json:"id"`
	Ratio float32 `json:"ratio"`
}

func (q *Queries) InsertRedditPostRatio(ctx context.Context, arg InsertRedditPostRatioParams) error {
	_, err := q.db.Exec(ctx, insertRedditPostRatio, arg.ID, arg.Ratio)
	return err
}

const insertRedditPostScore = `-- name: InsertRedditPostScore :exec
INSERT INTO reddit_post_score (id, ts, score)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditPostScoreParams struct {
	ID    string `json:"id"`
	Score int32  `json:"score"`
}

func (q *Queries) InsertRedditPostScore(ctx context.Context, arg InsertRedditPostScoreParams) error {
	_, err := q.db.Exec(ctx, insertRedditPostScore, arg.ID, arg.Score)
	return err
}

const insertRedditSubredditActiveUserCount = `-- name: InsertRedditSubredditActiveUserCount :exec
INSERT INTO reddit_subreddit_active_user_count (id, ts, active_user_count)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditSubredditActiveUserCountParams struct {
	ID              string `json:"id"`
	ActiveUserCount int32  `json:"active_user_count"`
}

func (q *Queries) InsertRedditSubredditActiveUserCount(ctx context.Context, arg InsertRedditSubredditActiveUserCountParams) error {
	_, err := q.db.Exec(ctx, insertRedditSubredditActiveUserCount, arg.ID, arg.ActiveUserCount)
	return err
}

const insertRedditSubredditSubscribers = `-- name: InsertRedditSubredditSubscribers :exec
INSERT INTO reddit_subreddit_subscribers (id, ts, subscribers)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditSubredditSubscribersParams struct {
	ID          string `json:"id"`
	Subscribers int32  `json:"subscribers"`
}

func (q *Queries) InsertRedditSubredditSubscribers(ctx context.Context, arg InsertRedditSubredditSubscribersParams) error {
	_, err := q.db.Exec(ctx, insertRedditSubredditSubscribers, arg.ID, arg.Subscribers)
	return err
}

const insertRedditUserAwardeeKarma = `-- name: InsertRedditUserAwardeeKarma :exec
INSERT INTO reddit_user_awardee_karma (id, ts, karma)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditUserAwardeeKarmaParams struct {
	ID    string `json:"id"`
	Karma int32  `json:"karma"`
}

func (q *Queries) InsertRedditUserAwardeeKarma(ctx context.Context, arg InsertRedditUserAwardeeKarmaParams) error {
	_, err := q.db.Exec(ctx, insertRedditUserAwardeeKarma, arg.ID, arg.Karma)
	return err
}

const insertRedditUserAwarderKarma = `-- name: InsertRedditUserAwarderKarma :exec
INSERT INTO reddit_user_awarder_karma (id, ts, karma)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditUserAwarderKarmaParams struct {
	ID    string `json:"id"`
	Karma int32  `json:"karma"`
}

func (q *Queries) InsertRedditUserAwarderKarma(ctx context.Context, arg InsertRedditUserAwarderKarmaParams) error {
	_, err := q.db.Exec(ctx, insertRedditUserAwarderKarma, arg.ID, arg.Karma)
	return err
}

const insertRedditUserCommentKarma = `-- name: InsertRedditUserCommentKarma :exec
INSERT INTO reddit_user_comment_karma (id, ts, karma)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditUserCommentKarmaParams struct {
	ID    string `json:"id"`
	Karma int32  `json:"karma"`
}

func (q *Queries) InsertRedditUserCommentKarma(ctx context.Context, arg InsertRedditUserCommentKarmaParams) error {
	_, err := q.db.Exec(ctx, insertRedditUserCommentKarma, arg.ID, arg.Karma)
	return err
}

const insertRedditUserLinkKarma = `-- name: InsertRedditUserLinkKarma :exec
INSERT INTO reddit_user_link_karma (id, ts, karma)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditUserLinkKarmaParams struct {
	ID    string `json:"id"`
	Karma int32  `json:"karma"`
}

func (q *Queries) InsertRedditUserLinkKarma(ctx context.Context, arg InsertRedditUserLinkKarmaParams) error {
	_, err := q.db.Exec(ctx, insertRedditUserLinkKarma, arg.ID, arg.Karma)
	return err
}

const insertRedditUserTotalKarma = `-- name: InsertRedditUserTotalKarma :exec
INSERT INTO reddit_user_total_karma (id, ts, karma)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertRedditUserTotalKarmaParams struct {
	ID    string `json:"id"`
	Karma int32  `json:"karma"`
}

func (q *Queries) InsertRedditUserTotalKarma(ctx context.Context, arg InsertRedditUserTotalKarmaParams) error {
	_, err := q.db.Exec(ctx, insertRedditUserTotalKarma, arg.ID, arg.Karma)
	return err
}
