// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: twitch-metrics.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTwitchClipMetricsByIDsBucket15Min = `-- name: GetTwitchClipMetricsByIDsBucket15Min :many
SELECT id, bucket, value, 'twitch.clip.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_clip_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchClipMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchClipMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchClipMetricsByIDsBucket15Min(ctx context.Context, arg GetTwitchClipMetricsByIDsBucket15MinParams) ([]GetTwitchClipMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getTwitchClipMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchClipMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetTwitchClipMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchClipMetricsByIDsBucket1Day = `-- name: GetTwitchClipMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'twitch.clip.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_clip_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchClipMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchClipMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchClipMetricsByIDsBucket1Day(ctx context.Context, arg GetTwitchClipMetricsByIDsBucket1DayParams) ([]GetTwitchClipMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getTwitchClipMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchClipMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetTwitchClipMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchClipMetricsByIDsBucket1Hr = `-- name: GetTwitchClipMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'twitch.clip.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_clip_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchClipMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchClipMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchClipMetricsByIDsBucket1Hr(ctx context.Context, arg GetTwitchClipMetricsByIDsBucket1HrParams) ([]GetTwitchClipMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchClipMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchClipMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetTwitchClipMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchClipMetricsByIDsBucket8Hr = `-- name: GetTwitchClipMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'twitch.clip.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_clip_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchClipMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchClipMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchClipMetricsByIDsBucket8Hr(ctx context.Context, arg GetTwitchClipMetricsByIDsBucket8HrParams) ([]GetTwitchClipMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchClipMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchClipMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetTwitchClipMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchStreamMetricsByIDsBucket15Min = `-- name: GetTwitchStreamMetricsByIDsBucket15Min :many
SELECT id, bucket, value, 'twitch.stream.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_stream_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchStreamMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchStreamMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchStreamMetricsByIDsBucket15Min(ctx context.Context, arg GetTwitchStreamMetricsByIDsBucket15MinParams) ([]GetTwitchStreamMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getTwitchStreamMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchStreamMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetTwitchStreamMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchStreamMetricsByIDsBucket1Day = `-- name: GetTwitchStreamMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'twitch.stream.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_stream_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchStreamMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchStreamMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchStreamMetricsByIDsBucket1Day(ctx context.Context, arg GetTwitchStreamMetricsByIDsBucket1DayParams) ([]GetTwitchStreamMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getTwitchStreamMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchStreamMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetTwitchStreamMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchStreamMetricsByIDsBucket1Hr = `-- name: GetTwitchStreamMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'twitch.stream.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_stream_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchStreamMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchStreamMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchStreamMetricsByIDsBucket1Hr(ctx context.Context, arg GetTwitchStreamMetricsByIDsBucket1HrParams) ([]GetTwitchStreamMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchStreamMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchStreamMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetTwitchStreamMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchStreamMetricsByIDsBucket8Hr = `-- name: GetTwitchStreamMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'twitch.stream.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_stream_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchStreamMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchStreamMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchStreamMetricsByIDsBucket8Hr(ctx context.Context, arg GetTwitchStreamMetricsByIDsBucket8HrParams) ([]GetTwitchStreamMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchStreamMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchStreamMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetTwitchStreamMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchUserPastDecMetricsByIDsBucket15Min = `-- name: GetTwitchUserPastDecMetricsByIDsBucket15Min :many
SELECT id, bucket, value, 'twitch.user-past-dec.avg-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(avg_views::REAL) AS "value"
	FROM twitch_user_past_dec_avg_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(med_views::REAL) AS "value"
	FROM twitch_user_past_dec_med_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(std_views::REAL) AS "value"
	FROM twitch_user_past_dec_std_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.avg-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(avg_duration::REAL) AS "value"
	FROM twitch_user_past_dec_avg_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(med_duration::REAL) AS "value"
	FROM twitch_user_past_dec_med_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(std_duration::REAL) AS "value"
	FROM twitch_user_past_dec_std_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchUserPastDecMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchUserPastDecMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchUserPastDecMetricsByIDsBucket15Min(ctx context.Context, arg GetTwitchUserPastDecMetricsByIDsBucket15MinParams) ([]GetTwitchUserPastDecMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getTwitchUserPastDecMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchUserPastDecMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetTwitchUserPastDecMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchUserPastDecMetricsByIDsBucket1Day = `-- name: GetTwitchUserPastDecMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'twitch.user-past-dec.avg-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(avg_views::REAL) AS "value"
	FROM twitch_user_past_dec_avg_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(med_views::REAL) AS "value"
	FROM twitch_user_past_dec_med_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(std_views::REAL) AS "value"
	FROM twitch_user_past_dec_std_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.avg-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(avg_duration::REAL) AS "value"
	FROM twitch_user_past_dec_avg_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(med_duration::REAL) AS "value"
	FROM twitch_user_past_dec_med_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(std_duration::REAL) AS "value"
	FROM twitch_user_past_dec_std_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchUserPastDecMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchUserPastDecMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchUserPastDecMetricsByIDsBucket1Day(ctx context.Context, arg GetTwitchUserPastDecMetricsByIDsBucket1DayParams) ([]GetTwitchUserPastDecMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getTwitchUserPastDecMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchUserPastDecMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetTwitchUserPastDecMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchUserPastDecMetricsByIDsBucket1Hr = `-- name: GetTwitchUserPastDecMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'twitch.user-past-dec.avg-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(avg_views::REAL) AS "value"
	FROM twitch_user_past_dec_avg_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(med_views::REAL) AS "value"
	FROM twitch_user_past_dec_med_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(std_views::REAL) AS "value"
	FROM twitch_user_past_dec_std_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.avg-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(avg_duration::REAL) AS "value"
	FROM twitch_user_past_dec_avg_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(med_duration::REAL) AS "value"
	FROM twitch_user_past_dec_med_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(std_duration::REAL) AS "value"
	FROM twitch_user_past_dec_std_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchUserPastDecMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchUserPastDecMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchUserPastDecMetricsByIDsBucket1Hr(ctx context.Context, arg GetTwitchUserPastDecMetricsByIDsBucket1HrParams) ([]GetTwitchUserPastDecMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchUserPastDecMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchUserPastDecMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetTwitchUserPastDecMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchUserPastDecMetricsByIDsBucket8Hr = `-- name: GetTwitchUserPastDecMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'twitch.user-past-dec.avg-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(avg_views::REAL) AS "value"
	FROM twitch_user_past_dec_avg_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(med_views::REAL) AS "value"
	FROM twitch_user_past_dec_med_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(std_views::REAL) AS "value"
	FROM twitch_user_past_dec_std_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.avg-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(avg_duration::REAL) AS "value"
	FROM twitch_user_past_dec_avg_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.med-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(med_duration::REAL) AS "value"
	FROM twitch_user_past_dec_med_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
UNION ALL
SELECT id, bucket, value, 'twitch.user-past-dec.std-duration' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(std_duration::REAL) AS "value"
	FROM twitch_user_past_dec_std_duration
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchUserPastDecMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchUserPastDecMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchUserPastDecMetricsByIDsBucket8Hr(ctx context.Context, arg GetTwitchUserPastDecMetricsByIDsBucket8HrParams) ([]GetTwitchUserPastDecMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchUserPastDecMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchUserPastDecMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetTwitchUserPastDecMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchVideoMetricsByIDsBucket15Min = `-- name: GetTwitchVideoMetricsByIDsBucket15Min :many
SELECT id, bucket, value, 'twitch.video.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '15 minutes', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_video_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchVideoMetricsByIDsBucket15MinParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchVideoMetricsByIDsBucket15MinRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchVideoMetricsByIDsBucket15Min(ctx context.Context, arg GetTwitchVideoMetricsByIDsBucket15MinParams) ([]GetTwitchVideoMetricsByIDsBucket15MinRow, error) {
	rows, err := q.db.Query(ctx, getTwitchVideoMetricsByIDsBucket15Min, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchVideoMetricsByIDsBucket15MinRow
	for rows.Next() {
		var i GetTwitchVideoMetricsByIDsBucket15MinRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchVideoMetricsByIDsBucket1Day = `-- name: GetTwitchVideoMetricsByIDsBucket1Day :many
SELECT id, bucket, value, 'twitch.video.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 day', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_video_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchVideoMetricsByIDsBucket1DayParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchVideoMetricsByIDsBucket1DayRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchVideoMetricsByIDsBucket1Day(ctx context.Context, arg GetTwitchVideoMetricsByIDsBucket1DayParams) ([]GetTwitchVideoMetricsByIDsBucket1DayRow, error) {
	rows, err := q.db.Query(ctx, getTwitchVideoMetricsByIDsBucket1Day, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchVideoMetricsByIDsBucket1DayRow
	for rows.Next() {
		var i GetTwitchVideoMetricsByIDsBucket1DayRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchVideoMetricsByIDsBucket1Hr = `-- name: GetTwitchVideoMetricsByIDsBucket1Hr :many
SELECT id, bucket, value, 'twitch.video.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '1 hour', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_video_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchVideoMetricsByIDsBucket1HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchVideoMetricsByIDsBucket1HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchVideoMetricsByIDsBucket1Hr(ctx context.Context, arg GetTwitchVideoMetricsByIDsBucket1HrParams) ([]GetTwitchVideoMetricsByIDsBucket1HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchVideoMetricsByIDsBucket1Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchVideoMetricsByIDsBucket1HrRow
	for rows.Next() {
		var i GetTwitchVideoMetricsByIDsBucket1HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTwitchVideoMetricsByIDsBucket8Hr = `-- name: GetTwitchVideoMetricsByIDsBucket8Hr :many
SELECT id, bucket, value, 'twitch.video.views' AS "metric"
FROM (
	SELECT
		id,
	    time_bucket(INTERVAL '8 hours', ts) AS "bucket",
	    MAX(views::REAL) AS "value"
	FROM twitch_video_views
	GROUP BY id, bucket
	ORDER BY id, bucket
) AS tab
WHERE
    tab.id ILIKE ANY($1::VARCHAR[]) AND
    tab.bucket >= $2::TIMESTAMPTZ AND
    tab.bucket <= $3::TIMESTAMPTZ
`

type GetTwitchVideoMetricsByIDsBucket8HrParams struct {
	Ids     []string           `json:"ids"`
	TsStart pgtype.Timestamptz `json:"ts_start"`
	TsEnd   pgtype.Timestamptz `json:"ts_end"`
}

type GetTwitchVideoMetricsByIDsBucket8HrRow struct {
	ID     string      `json:"id"`
	Bucket interface{} `json:"bucket"`
	Value  interface{} `json:"value"`
	Metric string      `json:"metric"`
}

func (q *Queries) GetTwitchVideoMetricsByIDsBucket8Hr(ctx context.Context, arg GetTwitchVideoMetricsByIDsBucket8HrParams) ([]GetTwitchVideoMetricsByIDsBucket8HrRow, error) {
	rows, err := q.db.Query(ctx, getTwitchVideoMetricsByIDsBucket8Hr, arg.Ids, arg.TsStart, arg.TsEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTwitchVideoMetricsByIDsBucket8HrRow
	for rows.Next() {
		var i GetTwitchVideoMetricsByIDsBucket8HrRow
		if err := rows.Scan(
			&i.ID,
			&i.Bucket,
			&i.Value,
			&i.Metric,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTwitchClipViews = `-- name: InsertTwitchClipViews :exec
INSERT INTO twitch_clip_views (id, ts, views)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchClipViewsParams struct {
	ID    string `json:"id"`
	Views int64  `json:"views"`
}

func (q *Queries) InsertTwitchClipViews(ctx context.Context, arg InsertTwitchClipViewsParams) error {
	_, err := q.db.Exec(ctx, insertTwitchClipViews, arg.ID, arg.Views)
	return err
}

const insertTwitchStreamViews = `-- name: InsertTwitchStreamViews :exec
INSERT INTO twitch_stream_views (id, ts, views)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchStreamViewsParams struct {
	ID    string `json:"id"`
	Views int64  `json:"views"`
}

func (q *Queries) InsertTwitchStreamViews(ctx context.Context, arg InsertTwitchStreamViewsParams) error {
	_, err := q.db.Exec(ctx, insertTwitchStreamViews, arg.ID, arg.Views)
	return err
}

const insertTwitchUserPastDecAvgDuration = `-- name: InsertTwitchUserPastDecAvgDuration :exec
INSERT INTO twitch_user_past_dec_avg_duration (id, ts, avg_duration)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchUserPastDecAvgDurationParams struct {
	ID          string  `json:"id"`
	AvgDuration float32 `json:"avg_duration"`
}

func (q *Queries) InsertTwitchUserPastDecAvgDuration(ctx context.Context, arg InsertTwitchUserPastDecAvgDurationParams) error {
	_, err := q.db.Exec(ctx, insertTwitchUserPastDecAvgDuration, arg.ID, arg.AvgDuration)
	return err
}

const insertTwitchUserPastDecAvgViews = `-- name: InsertTwitchUserPastDecAvgViews :exec
INSERT INTO twitch_user_past_dec_avg_views (id, ts, avg_views)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchUserPastDecAvgViewsParams struct {
	ID       string  `json:"id"`
	AvgViews float32 `json:"avg_views"`
}

func (q *Queries) InsertTwitchUserPastDecAvgViews(ctx context.Context, arg InsertTwitchUserPastDecAvgViewsParams) error {
	_, err := q.db.Exec(ctx, insertTwitchUserPastDecAvgViews, arg.ID, arg.AvgViews)
	return err
}

const insertTwitchUserPastDecMedDuration = `-- name: InsertTwitchUserPastDecMedDuration :exec
INSERT INTO twitch_user_past_dec_med_duration (id, ts, med_duration)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchUserPastDecMedDurationParams struct {
	ID          string  `json:"id"`
	MedDuration float32 `json:"med_duration"`
}

func (q *Queries) InsertTwitchUserPastDecMedDuration(ctx context.Context, arg InsertTwitchUserPastDecMedDurationParams) error {
	_, err := q.db.Exec(ctx, insertTwitchUserPastDecMedDuration, arg.ID, arg.MedDuration)
	return err
}

const insertTwitchUserPastDecMedViews = `-- name: InsertTwitchUserPastDecMedViews :exec
INSERT INTO twitch_user_past_dec_med_views (id, ts, med_views)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchUserPastDecMedViewsParams struct {
	ID       string  `json:"id"`
	MedViews float32 `json:"med_views"`
}

func (q *Queries) InsertTwitchUserPastDecMedViews(ctx context.Context, arg InsertTwitchUserPastDecMedViewsParams) error {
	_, err := q.db.Exec(ctx, insertTwitchUserPastDecMedViews, arg.ID, arg.MedViews)
	return err
}

const insertTwitchUserPastDecStdDuration = `-- name: InsertTwitchUserPastDecStdDuration :exec
INSERT INTO twitch_user_past_dec_std_duration (id, ts, std_duration)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchUserPastDecStdDurationParams struct {
	ID          string  `json:"id"`
	StdDuration float32 `json:"std_duration"`
}

func (q *Queries) InsertTwitchUserPastDecStdDuration(ctx context.Context, arg InsertTwitchUserPastDecStdDurationParams) error {
	_, err := q.db.Exec(ctx, insertTwitchUserPastDecStdDuration, arg.ID, arg.StdDuration)
	return err
}

const insertTwitchUserPastDecStdViews = `-- name: InsertTwitchUserPastDecStdViews :exec
INSERT INTO twitch_user_past_dec_std_views (id, ts, std_views)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchUserPastDecStdViewsParams struct {
	ID       string  `json:"id"`
	StdViews float32 `json:"std_views"`
}

func (q *Queries) InsertTwitchUserPastDecStdViews(ctx context.Context, arg InsertTwitchUserPastDecStdViewsParams) error {
	_, err := q.db.Exec(ctx, insertTwitchUserPastDecStdViews, arg.ID, arg.StdViews)
	return err
}

const insertTwitchVideoViews = `-- name: InsertTwitchVideoViews :exec
INSERT INTO twitch_video_views (id, ts, views)
VALUES ($1, NOW()::TIMESTAMPTZ, $2)
`

type InsertTwitchVideoViewsParams struct {
	ID    string `json:"id"`
	Views int64  `json:"views"`
}

func (q *Queries) InsertTwitchVideoViews(ctx context.Context, arg InsertTwitchVideoViewsParams) error {
	_, err := q.db.Exec(ctx, insertTwitchVideoViews, arg.ID, arg.Views)
	return err
}
