// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: metadata.sql

package dbgen

import (
	"context"

	jsonb "github.com/brojonat/kaggo/server/db/jsonb"
)

const getChildrenMetadataByID = `-- name: GetChildrenMetadataByID :many
SELECT
    m.id AS username,
    m.request_kind AS "parent_request_kind",
    children.id AS child_id,
    children.request_kind AS "child_request_kind",
    children."data" AS data
FROM metadata m
LEFT JOIN (
	SELECT
		id AS id,
        m2.request_kind AS request_kind,
		m2."data" AS "data",
		m2."data" ->> 'parent_user_name' AS parent_id
	FROM metadata m2
	WHERE m2.request_kind = $1
) children ON m.id = children.parent_id
WHERE m.id = $2 AND m.request_kind = $3
`

type GetChildrenMetadataByIDParams struct {
	ChildRequestKind  string `json:"child_request_kind"`
	ID                string `json:"id"`
	ParentRequestKind string `json:"parent_request_kind"`
}

type GetChildrenMetadataByIDRow struct {
	Username          string             `json:"username"`
	ParentRequestKind string             `json:"parent_request_kind"`
	ChildID           string             `json:"child_id"`
	ChildRequestKind  string             `json:"child_request_kind"`
	Data              jsonb.MetadataJSON `json:"data"`
}

func (q *Queries) GetChildrenMetadataByID(ctx context.Context, arg GetChildrenMetadataByIDParams) ([]GetChildrenMetadataByIDRow, error) {
	rows, err := q.db.Query(ctx, getChildrenMetadataByID, arg.ChildRequestKind, arg.ID, arg.ParentRequestKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildrenMetadataByIDRow
	for rows.Next() {
		var i GetChildrenMetadataByIDRow
		if err := rows.Scan(
			&i.Username,
			&i.ParentRequestKind,
			&i.ChildID,
			&i.ChildRequestKind,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetadataByIDs = `-- name: GetMetadataByIDs :many
SELECT id, request_kind, data
FROM metadata
WHERE id = ANY($1::VARCHAR[])
`

func (q *Queries) GetMetadataByIDs(ctx context.Context, ids []string) ([]Metadatum, error) {
	rows, err := q.db.Query(ctx, getMetadataByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metadatum
	for rows.Next() {
		var i Metadatum
		if err := rows.Scan(&i.ID, &i.RequestKind, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetadatum = `-- name: GetMetadatum :one
SELECT id, request_kind, data
FROM metadata
WHERE request_kind = $1 AND LOWER(id) = LOWER($2)
`

type GetMetadatumParams struct {
	RequestKind string `json:"request_kind"`
	ID          string `json:"id"`
}

func (q *Queries) GetMetadatum(ctx context.Context, arg GetMetadatumParams) (Metadatum, error) {
	row := q.db.QueryRow(ctx, getMetadatum, arg.RequestKind, arg.ID)
	var i Metadatum
	err := row.Scan(&i.ID, &i.RequestKind, &i.Data)
	return i, err
}

const insertMetadata = `-- name: InsertMetadata :exec
INSERT INTO metadata (id, request_kind, data)
VALUES ($1, $2, $3)
ON CONFLICT ON CONSTRAINT metadata_pkey DO UPDATE
SET data = EXCLUDED.data
`

type InsertMetadataParams struct {
	ID          string             `json:"id"`
	RequestKind string             `json:"request_kind"`
	Data        jsonb.MetadataJSON `json:"data"`
}

func (q *Queries) InsertMetadata(ctx context.Context, arg InsertMetadataParams) error {
	_, err := q.db.Exec(ctx, insertMetadata, arg.ID, arg.RequestKind, arg.Data)
	return err
}
